//это такая структура, которая содержит в качестве ключей только объекты и при помощи этой структуры мы можем избегать утечек данных в js

//как это происходит
let obj = {name: 'weakmap'}//допустим мы имеем такой объект
// const arr = [obj]// создадим новый объект
// obj = null// а теперь обнулим родительский объект , в этот момент сборщик мусора js убедившись что объект не используется очистит его и освободить память, которую он занимал

// console.log(obj)//при этом результат будет естественно null
// console.log(arr[0])//однако при этом созданный массив будет существовать вне зависимости от того , что родительского объекта уже нет, таким образом произойдёт утечка данных
//именно для таких ситуаций присутствует weakmap, который позволяет избежать утечки
const map = new WeakMap([// создадим карту через weakmap и включим в него массив состоящий из одного ключа-объекта со значением
    [obj, 'obj Data']
])
///get, set, delete, has : weakmapимеет только такие методы и поля


console.log(map.has(obj))
console.log(map.get(obj))

obj = null//но если мы обнулим объект, то сборщик мусора его ликвидирует и мы получим

console.log(map.has(obj))//ложь
console.log(map.get(obj))// undefined
console.log(map)//WeakMap { <items unknown> }- очень интересное сообщение слабого мепа

///практика приминения слабого мепа

const cache = new WeakMap()

function casheUser(user) {//допустим существует функция, с неким пользователем, в логике которой будем проверяться есть ли в кеше пользователь, при наличие его в кеше, он будет возвращен сразу же, если его нет в кеше, то она будет его заносить в кеш и только потом выводить
    if (!cache.has(user)) {
        cache.set(user, Date.now())
    }
    return cache.get(user)
}
//создав даух пользователей
let lena = {name: 'Elena'}
let alex = {name: 'Alex'}

casheUser(lena)//и пркешировав  пользователей, т.е. вызвав функцию
casheUser(alex)

console.log(cache.has(lena))// и вызвав
console.log(cache.has(alex))//вспомогательный метод мы убеждаемся, что такие пользователи есть в кеше, и другого не должно было быть
console.log(cache.get(lena))//и мы даже получаем их значения в кеше 
console.log(cache.get(alex))
lena = null//однако как только мы одного из пользователей удалим то, то автоматически он исчезнет из памяти без остатка
console.log(cache.has(lena))
console.log(cache.get(lena))// таким образом слабый меп гарантирует от утечки
console.log(cache.get(alex))









