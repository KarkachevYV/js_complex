//Прокси применяются в различных кейсах, а их безграничное множество
//Рассмотрим три разных состовляющих Прокси
//1-ая: wrapper(обёртка)
const withDefaultValue = (target, defaultValue = 0) => {//для  подобной реализации создадим функцию, которая будет давать значения ключам, которые не определены, об этом будет свидетельствовать defaultValue принимающая значение по умолчанию ноль или пустая строка.
    return new Proxy(target, {//и эта функция будет стрелочной функцией, вызывающая некую прокси, параметрами которой будет некая цель, в виде объекта, с единственным хендлером -геттер,
        get: (obj, prop) => (prop in obj ? obj[prop] : defaultValue)// который будет в своей логике определять наличие ключа и либо покажет его, либо укажет что оно равно нулю, которое установленное для всех ключей по умолчанию
    })
}

const position = withDefaultValue(//применяться данное прокси будет в неком объекте с некими определёнными ключами, и это будет некая система координат
    {
        x: 24,
        y: 42
    },
)

console.log(position)//соответственно и сам объект и его пары: ключ значения мы сразу сможем получить в консоли. Что при применении прокси прекрасно, что мы можем получать и не описанные ключи, к примеру - y, соответственно его значение будет ноль и понятно  почему, значения любого не описанного в системе координат ключа имеет установленное нами же выше значение по умолчанию.

//2-я: Hidden properies(скрытые свойства)
const withHiddenProps = (target, prefix = '_') => {//для этой реализации создадим функцию , которая будет прятать те, её свойства, на которые мы укажем, прятать будем ключи с наличием нижнего подчеркивания
    return new Proxy(target, {//для этого опять вызовем прокси, но уже с несколькими методами, описывающими совместно требуемую логику
        has: (obj, prop) => (prop in obj) && (!prop.startsWith(prefix)),//первый метод, при наличии нижнего подчеркивания(префикса) в названии ключа, не позволит его увидеть, для этого мы осуществим проверку, с использованием метода для строк: startsWith, которая проверит не начинается ли свойство с префикса иначе вызывается второй метод
        ownKeys: obj => Reflect.ownKeys(obj).filter(p => !p.startsWith(prefix)),//второй метод будет показывать ключи(свойства) имеющиеся в объекте через обращение к объекту Reflect, который позволяет этот функционал раскрыть, при этом мы отфильтруем через инверсию свойство префикс через метод filter с некой его итерированной переменной, которая не должна начинаться с префикса
        get: (obj, prop, receiver) => (prop in receiver ? obj[prop] : void  0)//  третий же  метод, бедет получать лишь те ключи , которые прошли через первые два метода,  показывает их, в противном случае он их скроит, на что указывает условие void 0.
    })
}

const data = withHiddenProps({//для проверки прокси  создадим некий объект , поле одного из которого начинается с префикса
    name: 'Yirii',
    age: 62,
    _uid: '1234567'
})// соответственно даже при наличие префикса поля в объекте , а data  в консоли на наличие такого ключа укажет,   data._uid укажет , что такого ключа  уже нет
//дальше, роверка '_uid' in data сообщит, что ключа в объекте нет, и проверка for (let key in data) console.log(key) выведит лишь ключи прошедшие проверку
//да и вызов  Object.keys(data) также покажет лишь ключи прошедшие проверку, тем самым этим функционалом мы можем отсекать для ознакомления  любую закрытую информацию , сделав её приватной.


//3-я: Optimization
const userData = [//допустим мы имеем некий массиви и допустим нам нужно найти некий его объект по его id
    {id: 1, name: 'Yirii', job: 'FullStack', age: 62},
    {id: 2, name: 'Vladimir', job: 'Student', age: 19},
    {id: 3, name: 'Svetlana', job: 'Backend', age: 20},
    {id: 4, name: 'Jorj', job: 'Teacher', age: 24}
]// вызвав в консоли метод find и указав ему соответствующий ключ userData.find(user => user.id === 3 мы получаем нужный объект, но такой подход поиска время затратен при большом количестве объектов
//а что сделать для того чтобы упростить эту задачу? в этом поможет использование прокси, которое существенно оптимизирует процесс
//для начала учтем следующее
const index = {}// некая переменная - массив
userData.forEach(i => (index[i.id] = i))// используя подобную команду, мы в консоли у этого массива получим тот объект, id которого мы явно переменной указываем (index[3]), и этот концепт мы и будем реализовать через прокси

const IndexeArray = new Proxy(Array, {//создав некую переменную-класс, мы через прокси создадим заглушку, которая и реализует нашу задачу. первым параметром прокси будет некий массив
    construct(target, [args]) {// а вторым, некий construct, ибо мы создали переменную-class, у которого первым параметром будет некий объект-цель, вторым - аргументы(массив и его объекты), а в логике будет return new target(...args) или результирующий массив, что является базовым использованием прокси, соответственно мы сразу же можем создать новую перменну users, как дочку от переменнй-класса и передать ей наш массив userData
        const index = {}//соответственно работая в прокси мы можем создать любой необходимый функционал, и мы этим воспользуемся. для начала мы вносим в логику прокси переменную индекс, содержащий карту массива
        args.forEach(item => (index[item.id] = item))//далее мы пробежимся по массиву как и выше, только будем пробегаться по массиву лишь один раз
        return new Proxy(new target(...args), {// а дальше запроксимируем базовую логику прокси или его результирующий массив 
            get(arr, prop) {//вызвав геттер(создав ловушку) со следующей логикой, ранее не доступной для массивов
                switch (prop) {//мы обращаемся к конструкции перебора switch у которого  default выдаёт arr[prop]
                    case 'push': //при этом, мы можем добавлять в конец новый элемент массива (по следующей логике)
                        return item => {//возвращаем вновь созданную функцию(злемент- item), для чего
                            index[item.id] = item
                            arr[prop].call(arr, item)//воспользуемся методом call, т.к. вводится один элемент, паралльельно обновив карту массива
                        }
                    case 'findBayId':// а также добавим изюминку: создадим свой некий метод, который будет брать id у нашей карты, а не у массива, и это как раз та оптимизация, к которой мы стримились и которая позволяет работать с массивами по ключу id
                        return id => index[id]
                    default:
                        return arr[prop]
                }
            }
        })
    }
})

const users = new IndexeArray([
    {id: 1, name: 'Yirii', job: 'FullStack', age: 62},
    {id: 2, name: 'Vladimir', job: 'Student', age: 19},
    {id: 3, name: 'Svetlana', job: 'Backend', age: 20},
    {id: 4, name: 'Jorj', job: 'Teacher', age: 24}
])


