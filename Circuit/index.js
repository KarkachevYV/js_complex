function createCalcFunction(n) {//создадим некую функцию, которая будет вызывать другую функцию
    return function() {
        console.log(1000*n)
    }
}

createCalcFunction(42)//простой вызов созданной функции ничего не даст, ибо она вызывает другую функцию
const calc = createCalcFunction(42)//это мы увидим, если создать переменную-функцию, равную данной, и тогда в консоли переменная-функции мы это и увидим
console.log(calc)//соответственно нам нужно вызвать её как функцию, для получения результата алгоритма в неё вписанного и для этого нужно её определить, что мы и сделали создав переменную-функцию, дело осталось за малым-за её вызовом
calc()//и вызов выдаст результат алгоритма в неё заложенный, при этом параметр (n) замкнёт некую функцию, передав значение параметра (n) в алгоритм переменной-функции.

/// примеры использования
function createIncrementor(n) {
    return function(num){
        return n + num
    }
}

const addOne = createIncrementor(1)
const addTen = createIncrementor(10)//получается на выходе мы имеем функцию с замыкающим параметром, который использует внутренняя функция для работы со своими параметрами
console.log(addOne(10))
console.log(addOne(41))
console.log(addTen(10))
console.log(addTen(10))

///очередной пример генерация ссылок

function urlGenerator(domain){
    return function(url) {
        return `https://${url}.${domain}`
    }
}
const otherUrl = urlGenerator('ru')
console.log(otherUrl('main')) //получаем ссылку на сайт mail
console.log(otherUrl('rutube'))// получаем ссылку на сайт rutub

///задача написать свою функцию bind со следующими вводными:
/*
function logPerson() {
    console.log('Person: ${this.name), ${this.age}, ${this.job} ')
}

const person1 = {name: 'Михаил', age: '22', job: 'Frontend'}
const person2 = {name: 'Елена', age: '19', job: 'SMM'}

bind(person1, logPerson)
bind(person2, logPerson)
*/
function bind(context, fn) {//первым парметром наша bind принимает контекст, который нужно привязать(замкнуть), вторым некую функцию.
    return function(...args) {//для её работы  воспользуемся замыканиями и вернём новую функцию, которой передадим с помощью оператора spred некий массив args
        fn.apply(context, args)//при реализации используем один из имеющихся методов, в результате чего и к которой будут переданы параметрами: как контекст, так и некий второй параметр с любым количеством переменных, массив, соответственно метод удовлетворяющая этим требованиям - apply, через него эти параметры мы и получим.
    }
д}
function logPerson() {//для получения контекста создадим функцию, которая нам позволит вывести такой контекст(такое количество переменных), какое необходимо,  какие будут заложены во второй параметр, в массив
    console.log(`Person: ${this.name}, ${this.age}, ${this.job} `)
}

const person1 = {name: 'Михаил', age: 22, job: 'Frontend'}//а далее создав некие примеры контекста, их может быть несколько, в данном случае это объекты, мы их через свою bind и вызовем, при этом 
const person2 = {name: 'Елена', age: 19, job: 'SMM'}

bind(person1, logPerson)()//обязательным и достаточным условием является указание, как всех параметров, а их два, так и сам вызов ().
bind(person2, logPerson)()