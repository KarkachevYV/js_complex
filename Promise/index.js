console.log('Request data...')//допустим мы делаем запрос к серверу

setTimeout(() => {
    console.log('Preraring data...')//и допустим на наш запрос сервер делает запрос к БД за 2 секунды
    const backendData = {// и допустим бекенд(сервер) нам отправляет некую информацию
        server: 'aws',
        port: 2000,
        status: 'working'
    }

    setTimeout(() => {//эмулирум асинхронность, через колбек(стрелочную функцию)
        backendData.modified = true//дополнительно сделав некую манипуляцию, к примеру modified
        console.log('Data received', backendData)
    }, 2000)
}, 2000)

/// в данном примере видим что один колбек вложен в другой, большую вложенность трудно подерживать, для упрощения этой задачи и пришли промесы.

const p = new Promise((resolve, reject) =>{
    setTimeout(() => {
        console.log('Preraring dataOne..')
        const backendData = {
            server: 'aws',
            port: 2000,
            status: 'working'
        } 
        resolve(backendData) 
    }, 5000)
})
/// на этом примере мы указываем логику промисов , когда мы добиваемся такого же результата, как и без них, соответственно и здесь присутствует вложенность, но это не обычная запись промисов, это только для показа его логики, промис работает также как и вложенная асинхронность стрелочных функций(колбеков)
p.then(data => {
    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {//эмулирум асинхронность, через колбек(стрелочную функцию)
            data.modified = true//дополнительно сделав некую манипуляцию, к примеру modified
            resolve(data)          
            
        }, 2000)
    })

    p2.then(clientData => {//вызываем новую стрелочную функцию, для получения её результата
        console.log('Data receivedClient', clientData)
    })
       console.log('Data reseived', data)
})

/// а вот здесь обычная запись промисов, где вложенность отсутствует, промисы могут сразу возвращать новый промис
p.then(data => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {//эмулирум асинхронность, через колбек(стрелочную функцию)
            data.modified = true//дополнительно сделав некую манипуляцию, к примеру modified
            resolve(data)  // изменение resolve на reject выдаст через метод  catch ошибку, при этом ошибка не позволит получить новые объекты промисов, с момента появления reject.      
            
        }, 2000)
    })
})
.then(clientDataOne => {//соответственно вместо создания новой переменной(при вложении) мы сразу вызываем метод then уже со значением новой переменной и тут же её получаем
    console.log('Data receivedClientOne', clientDataOne)
    clientDataOne.fromPromise = true
    return clientDataOne
})
.then(data => {
    console.log('Modified', data)
})
.catch(err => console.error('Erroe:', err))//это метод ошибок у промисов
.finally(() => console.log('Финал'))//данный метод промисов срабатывает независимо от наличия ошибок у промисов
/// при этом объект промиса (р) можно передовать куда угодно, в любой модуль, функцию, и т.д., и просто с помощью метода then говорить, что нужно сделать., когда промис будет выполнен.
/// помимо этого можно чейнить (.then) создавая цепочку различных модификаций данных обьекта промиса.

const sleep = ms => {//данным методом удобнее пользоваться, чем setTimeout, запись гораздо лаконичнее
    return new Promise(resolve => {
        setTimeout(() => resolve(), ms)
    })
}
sleep(2000).then(() => console.log('After 2 sec'))
sleep(3000).then(() => console.log('After 3 sec'))

Promise.all([sleep(2000), sleep(5000)]).then(() => {//данный метод срабатывает на последнем sleep массива. используется при запросе на сервер, чтобы скомпановатьт конечный результат.
})
Promise.race([sleep(2000), sleep(5000)]).then(() => {// данный метод срабатывает на первом sleep массива, его использование удобно для знания первичности выполнения из всех промисов.
    console.log('Race promises')
})
//
//промисы это обёртка, над асинхронностью, которая позволяет увеличить удобство написания кода, 