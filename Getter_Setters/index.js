const person = Object.create(
    {
        calculateAge() {
            console.log('Age', new Date().getFullYear() - this.birthYear)
        }
    },// первая фигурная - предназначена для передачи в неё прототипов
    {
    name: {
        value: 'Yirii',
        enumerable: false,//по умолчанию, именно данная пара, делает opacity
        writable: false, //по умолчанию, именно данная пара, делает пару const которую нельзя менять
        configurable: false //по умолчанию ключ удалять нельзя
        ///протородескрипторы:enumerable, writable, configurable  - обязательные ключи Object.create
    },
    birthYear: {
        value: 1961,
        enumerable: true,// при true opacity исчезает
        writable: true, // соответственно здесь у пары можно изменить значение, переназначив её
        configurable: true // соответственно этот ключ можно удолить
    },
    /// огеттерах и сеттерах: к примеру введем ещё одно поле объекта получаемое и изменяемое при помощи геттера и сеттера
    age: {
        get(){
            return new Date().getFullYear() - this.birthYear// данный геттер вычисляет значения возраста и передаёт его в поле через сеттер,
            
        },
        set(value) {
            console.log('Set age:', value)// при этом сеттер может изменить возраст, тем не менее не меняя его в поле возраст объекта
            document.body.style.background = 'red'// кроме всего прочего сеттер позволяет менять всё что угодно на странице, 
        }
    // на геттерах и сеттерах построено большое количествор фреймворков, для того чтобы смотреть за изменением определённых полей и выполнять дополнительную логику, например по отрисовке приложения
    ///геттеры и сеттеры позволят безгранично увеличивать функционал для усиления его реактивности и динамичности, при написании подобных конструкций
    }
    })

    person.birthYear = 1960
    console.log(person)//вывод с opacity у object.created, подобным образом выделяются объекты, поля которых не могут учавствовать в циклах

    for (let key in person) {// циклы применяются при итерации полей, однако только для тех у кого нет opacity
        if (person.hasOwnProperty(key)) {// данный  метод рекомендуется к применению, когда используется итерация for in, который позволяет не пробегаться по прототипу.
            console.log('key', key, person [key])
        }
    }