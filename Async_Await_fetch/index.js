const delay = ms => {//создадим функцию , которая нам будет возвращать промис, через некую искусственную задержку
    return new Promise(r => setTimeout(() => r(), ms))
}

delay(2000).then(() => console.log('2  sec'))//для теста воспользуемся методом then , который имеется у промисов, результат вывода сообщения в консоль показывает верность работы созданной функции

// усложним задачу , допустим мы сделаем запрос на сервер для этого скопируем необходимую ссылку сервера: https://jsonplaceholder.typicode.com/todos
const url = 'https://jsonplaceholder.typicode.com/todos'//далее  создадим переменную url значением которой будет выбранная ссылка на сервер

function  fetchTodos() {// а создав некую (родительскую) функцию, которая будет вызывать промис с некой задержкой delay
    delay(2000).then(() => {
        fetch(url).then(response => response.json())//и воспользовавшись нативным браузерным методом fetch, в котором вызвав метод  then с неким response, для которого в свою очередь вызовем метод json, ибо ответ от сервера будет в виде json, мы получим затребованный по запросу объект- response.
    })
}
//а так как мы используем промис(находимся внутри его), то форма записи может быть более соответствующей промисам:
function  fetchTodos() {
    console.log('Fetch todo started...')
    return delay(2000)//delay получаем от fetchTodos
    //     .then(() => {
    //     return fetch(url)//fetch получаем от delay
    // }).then(response => response.json())//вызывая соответствующие им then
        .then(() => fetch(url))
        .then(response => response.json())//однако, запись функционала моно ещё сократить иэти две строки эквивалент трёх верхних
}
// дтеперь для получения вызова, нам достаточно вызвать лишь родительскую функцию, без параметров(аргументов) через then куда помещается некая data
fetchTodos()
    .then(data => {
        console.log('Data', data)
    })
    .catch(e => console.error(e))//дополнительно вызвав catch мы осуществим проверку и на ошибки запроса

/// однако и это не все сокращения функционала, в js имеются операторы Async и Await, которые ещё проще выполняют эти задачи, первый оператор указывает на асинронность некой функции,и он указывается обязательно и обязательно к родительской функции, а второй  автоматически обрабатывая промисы , позволяет получать результаты в виде переменных, которые создаются как результат работы второго оператора и соответствующего метода промиса
///при этом для использования других методов промисов, таких как catch и finally в js созданы такие ключевые слова как try  и catch, при их использовании функционал оборачивается этими ключевыми словами, у которых есть блок finally, который необходим на случай ошибки
async function fetchAsyncTodos() {
    console.log('Fetch todo started...')
    try {
        await delay(2000)
        const response = await fetch(url)
        const data = await response.json()
        console.log('Data', data)
    } catch(e) {
        console.error(e)
    } finally {
        console.log('End..')
    }//
    
}
fetchAsyncTodos()//соответственно без вызова самой функции функционал не заработает и не бует никаких результатов, после создания функции для получения её результатов вызов её обязателен.


